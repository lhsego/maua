% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/saUtil_log.R
\name{saUtil_log}
\alias{saUtil_log}
\title{The single attribute logarithmic utility function}
\usage{
saUtil_log(z, shift = 0, zrange = range(z), urange = c(0, 1))
}
\arguments{
\item{z}{A numeric vector of attribute measurements, or values, in their native scale}

\item{shift}{A numeric value that shifts the \code{z} values by \code{z - shift} before taking the log. One situtation where this
is useful is when one or more values of \code{z} are negative.}

\item{zrange}{A vector with 2 elements containing the minimum and maximum possible values of the attribute.
However, because the log function goes to \code{-Infty} as \code{z} goes to 0, \code{zrange[1]} fixes a
lower endpoint such that \emph{u(zrange[1]) = urange[1]}.}

\item{urange}{A vector with 2 elements indicating the range of the utility function. \code{urange[1]}
is the mapping of \code{zrange[1]}, and \code{urange[2]} is the mapping of \code{zrange[2]}.}
}
\value{
An object of class \code{saUtilCall}, which includes the utility values of \code{z}.  This object can be
printed or plotted via \code{\link{print.saUtilCall}} or \code{\link{plot.saUtilCall}}.
}
\description{
The single attribute logarithmic utility function
}
\details{
The log utility function may be increasing or decreasing (depending on the choice of
\code{urange}).  Raw data values are shifted by \code{shift} prior to taking the log.

The log utility function is given by:
\emph{u(z) = urange[1] + (urange[2] - urange[1]) * A / B}
where \emph{A = log(z - shift) - log(zrange[1] - shift)} and
\emph{ B = log(zrange[2] - shift) - log(zrange[1] - shift)}.

Note \emph{u(zrange[1]) = urange[1]} and \emph{u(zrange[2]) = urange[2]}.
}
\examples{
# An identify
saUtil_log(exp(0:10), urange = c(0, 10))

# Just mapping the log(1:10) to (0, 1)
saUtil_log(1:10)

# Suppose we have seven classes, and p contains probabilities assigned
# to the true class for 5 observations
p <- c(0.3, 0.8, 0.99, 0.05, 1/7)

# This calculate the log score, but ensure that scores that do worse than
# guessing (i.e. uniform, 1/7) are mapped to a negative value
saUtil_log(p, zrange = c(1/7, 1))

# Example of the shift to move us away from NA and -Inf
x <- saUtil_log(-5:7, shift = -5.00001)
print(x)
plot(x)
attributes(x)
}

